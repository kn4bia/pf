"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLegendY = exports.getLegendX = exports.getLegendDimensions = void 0;

var _victory = require("victory");

var _victoryCore = require("victory-core");

var _ChartTheme = require("../ChartTheme");

var _chartPadding = require("./chart-padding");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Returns legend dimensions
var getLegendDimensions = function getLegendDimensions(_ref) {
  var legendData = _ref.legendData,
      legendOrientation = _ref.legendOrientation,
      legendProps = _ref.legendProps,
      theme = _ref.theme;

  if (legendData || legendProps.data) {
    return _victory.VictoryLegend.getDimensions(_objectSpread({
      data: legendData,
      orientation: legendOrientation,
      theme: theme
    }, legendProps));
  }

  return {};
}; // Returns x coordinate for legend


exports.getLegendDimensions = getLegendDimensions;

var getLegendX = function getLegendX(_ref2) {
  var chartWidth = _ref2.chartWidth,
      _ref2$dx = _ref2.dx,
      dx = _ref2$dx === void 0 ? 0 : _ref2$dx,
      legendData = _ref2.legendData,
      legendOrientation = _ref2.legendOrientation,
      legendPosition = _ref2.legendPosition,
      legendProps = _ref2.legendProps,
      svgWidth = _ref2.svgWidth,
      theme = _ref2.theme;
  var legendDimensions = getLegendDimensions({
    legendData: legendData,
    legendOrientation: legendOrientation,
    legendProps: legendProps,
    theme: theme
  });
  var textSizeWorkAround = getTextSizeWorkAround({
    legendData: legendData,
    legendOrientation: legendOrientation,
    theme: theme
  });

  switch (legendPosition) {
    case 'bottom':
      return svgWidth > legendDimensions.width - textSizeWorkAround ? Math.round((svgWidth - (legendDimensions.width - textSizeWorkAround)) / 2) + dx : dx;

    case 'bottom-left':
      return dx;

    case 'right':
      return chartWidth + _ChartTheme.ChartCommonStyles.legend.margin + dx;

    default:
      return dx;
  }
}; // Returns y coordinate for legend


exports.getLegendX = getLegendX;

var getLegendY = function getLegendY(_ref3) {
  var chartHeight = _ref3.chartHeight,
      _ref3$dy = _ref3.dy,
      dy = _ref3$dy === void 0 ? 0 : _ref3$dy,
      legendPosition = _ref3.legendPosition,
      chartType = _ref3.chartType,
      legendData = _ref3.legendData,
      legendOrientation = _ref3.legendOrientation,
      legendProps = _ref3.legendProps,
      theme = _ref3.theme;
  // Chart height with padding
  var defaultPadding = {
    bottom: (0, _chartPadding.getPaddingForSide)('bottom', theme[chartType].padding, 0),
    top: (0, _chartPadding.getPaddingForSide)('top', theme[chartType].padding, 0)
  };
  var chartPadding = defaultPadding.bottom + defaultPadding.top + 4;
  var cHeight = chartHeight ? chartHeight + chartPadding : 0; // Legend width with padding

  var legendDimensions = getLegendDimensions({
    legendData: legendData,
    legendOrientation: legendOrientation,
    legendProps: legendProps,
    theme: theme
  });

  var legendPadding = function legendPadding(legendData) {
    return legendData && legendData.length > 0 ? 15 : 0;
  };

  var lHeight = legendDimensions.height ? legendDimensions.height + legendPadding(legendData) : 0;

  switch (legendPosition) {
    case 'bottom':
    case 'bottom-left':
      return chartHeight + _ChartTheme.ChartCommonStyles.legend.margin + dy;

    case 'right':
      return cHeight > lHeight ? Math.round((cHeight - lHeight) / 2) + dy : dy;

    default:
      return dy;
  }
}; // Returns an approximation of over-sized text width due to growing character count
//
// See https://github.com/FormidableLabs/victory/issues/864


exports.getLegendY = getLegendY;

var getTextSizeWorkAround = function getTextSizeWorkAround(_ref4) {
  var legendData = _ref4.legendData,
      legendOrientation = _ref4.legendOrientation,
      theme = _ref4.theme;
  var style = theme.legend.style.labels;

  if (!(legendData && style.fontFamily.includes('overpass'))) {
    return 0;
  } // For horizontal legends, account for the growing char count of the last legend item


  var result = legendData[legendData.length - 1].name; // For vertical legends, account for the growing char count of the longest legend item

  if (legendOrientation === 'vertical') {
    legendData.forEach(function (data) {
      if (data.name && data.name.length > result.length) {
        result = data.name;
      }
    });
  }

  var textSize = _victoryCore.TextSize.approximateTextSize(result, style);

  var adjustedTextSize = _victoryCore.TextSize.approximateTextSize(result, _objectSpread({}, style, {
    characterConstant: 2.5875 // Average pixels per glyph

  }));

  return Math.abs(textSize.width - adjustedTextSize.width);
};
//# sourceMappingURL=chart-legend.js.map