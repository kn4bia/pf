function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { VictoryLegend } from 'victory';
import { TextSize } from 'victory-core';
import { ChartCommonStyles } from '../ChartTheme';
import { getPaddingForSide } from "./chart-padding";
// Returns legend dimensions
export const getLegendDimensions = ({
  legendData,
  legendOrientation,
  legendProps,
  theme
}) => {
  if (legendData || legendProps.data) {
    return VictoryLegend.getDimensions(_objectSpread({
      data: legendData,
      orientation: legendOrientation,
      theme
    }, legendProps));
  }

  return {};
}; // Returns x coordinate for legend

export const getLegendX = ({
  chartWidth,
  dx = 0,
  legendData,
  legendOrientation,
  legendPosition,
  legendProps,
  svgWidth,
  theme
}) => {
  const legendDimensions = getLegendDimensions({
    legendData,
    legendOrientation,
    legendProps,
    theme
  });
  const textSizeWorkAround = getTextSizeWorkAround({
    legendData,
    legendOrientation,
    theme
  });

  switch (legendPosition) {
    case 'bottom':
      return svgWidth > legendDimensions.width - textSizeWorkAround ? Math.round((svgWidth - (legendDimensions.width - textSizeWorkAround)) / 2) + dx : dx;

    case 'bottom-left':
      return dx;

    case 'right':
      return chartWidth + ChartCommonStyles.legend.margin + dx;

    default:
      return dx;
  }
}; // Returns y coordinate for legend

export const getLegendY = ({
  chartHeight,
  dy = 0,
  legendPosition,
  chartType,
  legendData,
  legendOrientation,
  legendProps,
  theme
}) => {
  // Chart height with padding
  const defaultPadding = {
    bottom: getPaddingForSide('bottom', theme[chartType].padding, 0),
    top: getPaddingForSide('top', theme[chartType].padding, 0)
  };
  const chartPadding = defaultPadding.bottom + defaultPadding.top + 4;
  const cHeight = chartHeight ? chartHeight + chartPadding : 0; // Legend width with padding

  const legendDimensions = getLegendDimensions({
    legendData,
    legendOrientation,
    legendProps,
    theme
  });

  const legendPadding = legendData => legendData && legendData.length > 0 ? 15 : 0;

  const lHeight = legendDimensions.height ? legendDimensions.height + legendPadding(legendData) : 0;

  switch (legendPosition) {
    case 'bottom':
    case 'bottom-left':
      return chartHeight + ChartCommonStyles.legend.margin + dy;

    case 'right':
      return cHeight > lHeight ? Math.round((cHeight - lHeight) / 2) + dy : dy;

    default:
      return dy;
  }
}; // Returns an approximation of over-sized text width due to growing character count
//
// See https://github.com/FormidableLabs/victory/issues/864

const getTextSizeWorkAround = ({
  legendData,
  legendOrientation,
  theme
}) => {
  const style = theme.legend.style.labels;

  if (!(legendData && style.fontFamily.includes('overpass'))) {
    return 0;
  } // For horizontal legends, account for the growing char count of the last legend item


  let result = legendData[legendData.length - 1].name; // For vertical legends, account for the growing char count of the longest legend item

  if (legendOrientation === 'vertical') {
    legendData.forEach(data => {
      if (data.name && data.name.length > result.length) {
        result = data.name;
      }
    });
  }

  const textSize = TextSize.approximateTextSize(result, style);
  const adjustedTextSize = TextSize.approximateTextSize(result, _objectSpread({}, style, {
    characterConstant: 2.5875 // Average pixels per glyph

  }));
  return Math.abs(textSize.width - adjustedTextSize.width);
};
//# sourceMappingURL=chart-legend.js.map